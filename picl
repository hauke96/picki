#!/bin/bash

set -e

# Application properties
author="Hauke Stieler"
contact="mail a hauke-stieler.de"
codebase="https://github.com/hauke96/picl"
license="GPLv3"
version="0.1"

# Default settings
conf_file="./picl.conf"
output_folder="./libs"
url=
library_version=
library_name=
library_name_raw=
library_ext=
operatoin=

# usage
#
# Shows the help-message.
#
# Arguments: 
#   (none)
#
# Variables:
#   (none)
function usage(){
	cat <<END
Usage: picl [OPTIONS...] {COMMAND} [OPTIONS...] {LIBRARY}

Loads and manages simple libraries and files.

Normal options:
  -h, --help      Shows this help message

Commands:
  install         Installs the given library
  remove          Uninstalls/removes the given library

Options for the "install" command (all of these are optional):
  -h, --help      Shows this help message
  -c, --config    Specifies the configuration file that should be used. This
                  is "./picl.conf" by default.
  -o, --output    Specifies the output folder where all libraries should be
                  stored. This is "./libs" by default.
  -u, --url       The base url where picl downloads files from.

Options for the "remove" command (all of these are optional):
  -h, --help      Shows this help message

Library name at the end:
  This name if the library name inclusing the version you wan't do deal with.
  Ths name has the following format:

      my-library@3.5.1

  There must be a name and there must be a version. The version is basically
  the string that is behind the "@" and is not parsed. It just has to exist
  on the server and the format "x.y.z" (e.g. 3.5.1) is recommended.

General information:
  Version:    $version
  License:    $license
  Written by: $author
  Contact:    $contact
  Code repo:  $codebase
END
}

# parse_conf_file
#
# Parses the conf file and saves the entries in the global variables.
# The config file "picl.conf" should exist.
# 
# This function will NOT overwrite existing values, because CLI-arguments
# have a higher priority then values from the config file.
#
# Arguments:
#   (none)
#
# Variables:
#   url
#   output_folder
function parse_conf_file(){
	echo "Loading conf file $conf_file"

	while IFS= read -r line
	do
		key=${line%%\:*}
		value=${line#*:}

		case $key in
		url)
			_url=$value
			# remove / at end (if none exists, nothing happens)
			_url=${_url%/}
			# set if undefined, otherwise, leave variable unchanged
			url="${url:-$_url}"
			;;
		output_folder)
			_output_folder=$value
			# remove / at end (if none exists, nothing happens)
			_output_folder=${_output_folder%/}
			# set if undefined, otherwise, leave variable unchanged
			output_folder=${output_folder:-$_output_folder}
			;;
		\#*)
			# Lines with a "#" at the beginning are comments
			;;
		+)
			echo "Unknown config entry '$line'"
			;;
		esac
	done < $conf_file
}

# parse_metafile
#
# Parses the given meta file and re-sets the global variables listed below.
#
# Arguments:
#   meta_file
#
# Variables:
#   library_ext
function parse_meta_file(){
	meta_file="$1"

	echo "Parsing meta file $meta_file"

	while IFS= read -r line
	do
		key=${line%%\:*}
		value=${line#*:}

		case $key in
		ext)
			library_ext=$value
			;;
		\#*)
			# Lines with a "#" at the beginning are comments
			;;
		+)
			echo "Unknown meta entry '$line'"
			;;
		esac
	done < $meta_file
}

# parse_install_args
#
# Parses the args passed to the install operation.
#
# Arguments:
#   @
#
# Variables:
#   library_name
#   library_version
function parse_install_args(){
	# Gets the library specification (including version) 

	for (( i=2; i<=$#; i++ ))
	do
		arg_i=${@:$i:1}   # get argument i
		arg_j=${@:$i+1:1} # get argument i+1

		case $arg_i in
		-h|--help)
			usage
			exit 0
			;;
		-c)
			conf_file=$arg_j
			((i++))
			;;
		--config=*)
			conf_file=${arg_i#*=}
			;;
		-o)
			output_folder=${arg_j#*./}
			# remove / at end (if none exists, nothing happens)
			output_folder=${output_folder%/}
			((i++))
			;;
		--output=*)
			# split at = char and remove the shortest match from beginning
			output_folder=${arg_i#*=}
			# remove / at end (if none exists, nothing happens)
			output_folder=${output_folder%/}
			;;
		-u)
			url=$arg_j
			# remove / at end (if none exists, nothing happens)
			url=${url%/}
			((i++))
			;;
		--url=*)
			# split at = char and remove the shortest match from beginning
			url=${arg_i#*=}
			# remove / at end (if none exists, nothing happens)
			url=${url%/}
			;;
		*)
			library_name_raw=$arg_i
			break
			;;
		esac
	done

	# TODO handle empty library_name_raw

	library_name=${library_name_raw%%\@*}
	library_version=${library_name_raw#*\@}
}

# parse_remove_args
#
# Parses the args passed to the remove operation.
#
# Arguments:
#   @
#
# Variables:
#   library_name
#   library_version
function parse_remove_args(){
	# Gets the library specification (including version) 

	for (( i=2; i<=$#; i++ ))
	do
		arg_i=${@:$i:1}   # get argument i
		arg_j=${@:$i+1:1} # get argument i+1

		case $arg_i in
		-h|--help)
			usage
			exit 0
			;;
		*)
			library_name_raw=$arg_i
			break
			;;
		esac
	done

	# TODO handle empty library_name_raw

	library_name=${library_name_raw%%\@*}
	library_version=${library_name_raw#*\@}
}

# install
#
# Installs the library specified by the global variables
#
# Arguments:
# (none)
#
# Variables:
# (none)
function install(){
	echo ""
	echo "Start installing..."

	if [ ! -d "$output_folder" ]
	then
		echo "Folder $output_folder does not exist. I'll create it."
		mkdir $output_folder
	fi

	meta_file="$output_folder/meta_$library_name_raw"
	meta_url="$url/$library_name_raw/meta"
	library_ext=
	library_file=

	# Get meta file from server
	echo "Download meta file..."
	response=$(curl --write-out %{http_code} --silent --output $meta_file $meta_url)

	if [ "$response" -ne 200 ]
	then
		echo "Download meta file for $library_name in version $library_version failed"
		echo "HTTP status code: $response"
		exit 1
	fi

	parse_meta_file "$meta_file"

	echo "Library $library_name_raw has file extension '$library_ext'"

	# TODO parse dependencies
	# TODO check if every dependency exists
	# TODO download dependencies first
	# TODO check if file exists

	# TODO download actual library
	library_file="$output_folder/$library_name_raw$library_ext"
	echo "Download library $library_name_raw"
	response=$(curl --write-out %{http_code} --silent --output $library_file "$url/$library_name_raw/$library_name_raw$library_ext")

	if [ "$response" -ne 200 ]
	then
		echo "Download library $library_name_raw failed"
		echo "HTTP status code: $response"
		exit 1
	fi
	
	echo "Installing $library_name_raw finished"
}


# remove
#
# Removes the given library.
#
# Arguments:
#   library name (e.g. foo@1.2.3)
#
# Variables:
# (none)
function remove(){
	echo ""
	echo "Start installing..."

	meta_file="$output_folder/meta_$library_name_raw"

	parse_meta_file $meta_file

	library_file="$output_folder/$library_name_raw$library_ext"

	if [ -a $library_file ]
	then
		echo "Removing library $library_name_raw"
		rm -f $library_file
		echo "Removing meta file $meta_file"
		rm -f $meta_file
	else
		(>&2 echo "Library file $library_file does no exist")
	fi
}

case ${@:1:1} in
-h|--help)
	usage
	exit 0
	;;
install)
	parse_install_args $@
	operation=install
	;;
remove)
	parse_remove_args $@
	operation=remove
	;;
*)
	echo ""
	echo "Unknown operation '$operation'."
	echo "Use '-h' or '--help' for more information."
	exit 1
	;;
esac

parse_conf_file

echo ""
echo "Using the following configuration:"
echo ""
echo "url             : $url"
echo "output folder   : $output_folder"
echo "library name    : $library_name"
echo "library version : $library_version"
echo "operation       : $operation" 

case $operation in
install)
	install
	;;
remove)
	remove
	;;
# TODO else cases fot unknown and not specified operations. Because of the fact that we already parsed the operation string, should this never happen
esac
